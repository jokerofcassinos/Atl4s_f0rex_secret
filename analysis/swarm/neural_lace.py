
import logging
import numpy as np
import time
from typing import Dict, Any, List, Optional
from core.interfaces import SubconsciousUnit, SwarmSignal
from core.consciousness_bus import ConsciousnessBus

logger = logging.getLogger("NeuralLace")

class NeuralLace(SubconsciousUnit):
    """
    Phase 101: The Neural Lace (Hyper-Swarm Aggregation).
    
    A Synaptic Weighting System that learns which agents to trust.
    It acts as the 'Prefrontal Cortex', synthesizing all subconscious inputs into a final decision.
    
    Algorithm: Online Weighted Majority (Winnow / Exp. weights)
    """
    def __init__(self, bus: ConsciousnessBus):
        super().__init__("Neural_Lace")
        self.bus = bus
        self.weights = {} # {agent_name: weight}
        self.learning_rate = 0.1
        self.last_prediction = {} # {agent_name: signal_type} from previous tick
        self.last_price = 0.0
        
    async def process(self, context: Dict[str, Any]) -> Optional[SwarmSignal]:
        tick = context.get('tick')
        if not tick: return None
        
        current_price = tick['bid']
        
        # 1. Learning Step (Backpropagation of Truth)
        # Did the price move up or down since last tick?
        if self.last_price != 0:
            delta = current_price - self.last_price
            
            if abs(delta) > 0.5: # meaningful move
                direction = 1 if delta > 0 else -1
                
                # Reward/Punish agents based on last prediction
                for agent, signal in self.last_prediction.items():
                    if agent not in self.weights: self.weights[agent] = 1.0
                    
                    prediction = 0
                    if signal == "BUY": prediction = 1
                    elif signal == "SELL": prediction = -1
                    
                    # Update Weight
                    if prediction == direction:
                        self.weights[agent] *= (1.0 + self.learning_rate) # Boost
                    elif prediction != 0:
                         self.weights[agent] *= (1.0 - self.learning_rate) # Penalize
                         
                    # Clamp weights
                    self.weights[agent] = max(0.1, min(self.weights[agent], 10.0))
        
        self.last_price = current_price
        
        # 2. Aggregation Step (Feedforward)
        # Gather all current thoughts from the Bus
        # Using get_recent_thoughts() clears the bus, so we must be careful if we are the only consumer?
        # Actually, Orchestrator might have already consumed them?
        # NO. Orchestrator consumes thoughts via `self.bus.register_thought`.
        # `get_recent_thoughts` is usually called by the Orchestrator to *log* or *analyze*.
        # BUT WeaverSwarm calls it too.
        # If WeaverSwarm calls `get_recent_thoughts`, it CLEARS the bus.
        # This implies a race condition or data loss if multiple agents consume thoughts.
        # Ideally, `get_recent_thoughts` should NOT clear, or we relying on the memory being shared?
        # Checking `consciousness_bus.py`: `get_recent_thoughts` -> `self.memory_stream = []`.
        # THIS IS A BUG if multiple agents need to see thoughts.
        # However, `WeaverSwarm` is currently the only consumer inside the loop?
        # If I add `NeuralLace`, and it runs AFTER `WeaverSwarm`, the bus will be empty!
        
        # FIX: The Orchestrator collects thoughts in `current_signals` dict during the loop.
        # But `NeuralLace` runs *as an agent* inside the loop.
        # It needs to access the thoughts generated by *previous* agents in the *same* loop.
        # The Bus `memory_stream` contains them. 
        # But if WeaverSwarm cleared them, NeuralLace sees nothing.
        
        # Hack for now: NeuralLace assumes it runs AFTER WeaverSwarm and WeaverSwarm logic is modified 
        # OR we rely on internal state tracking relative to the bus.
        # Wait, I previously modified WeaverSwarm to call `get_recent_thoughts()`.
        # I should probably check if `WeaverSwarm` consumed everything.
        
        # STRATEGY: 
        # NeuralLace will peek at the bus (I can't peek easily).
        # OR I rely on the fact that NeuralLace is "The Mind".
        # Let's assume for this step, NeuralLace uses `get_recent_thoughts()` and if empty, returns None.
        # BUT `WeaverSwarm` just cleared it.
        # So I need to modify `ConsciousnessBus` to allow non-destructive reading OR
        # Modify `WeaverSwarm` to not clear.
        
        # 2. Aggregation Step (Feedforward)
        # We peek at the stream to see what everyone said.
        thoughts = self.bus.peek_thoughts()
        
        # Actually, checking `WeaverSwarm` again. It calls `get_recent_thoughts()` and CLEARS.
        # So NeuralLace will see nothing if it runs after Weaver.
        # UNLESS NeuralLace runs BEFORE Weaver?
        # But NeuralLace aggregates everything.
        
        # I will implement `NeuralLace` to use `bus.memory_stream` directly (peeking)
        # AND I will assume Weaver might have cleared it. 
        # If Weaver cleared it, I am blind.
        
        # CRITICAL FIX: I should patch `ConsciousnessBus` to allow peeking or shared access.
        # But limited scope.
        # Let's try to assume NeuralLace runs *instead* of logic in Orchestrator or *is* the logic.
        
        # For now, I will grab whatever is in the stream.
        
        vote_balance = 0.0
        total_weight = 0.0
        
        self.last_prediction = {}
        
        for thought in thoughts:
            agent = thought.source
            if agent == self.name: continue # Don't listen to self
            
            w = self.weights.get(agent, 1.0)
            
            val = 0
            if thought.signal_type == "BUY": val = 1
            elif thought.signal_type == "SELL": val = -1
            
            # Weighted Vote
            # Signal Confidence is also a factor
            signal_weight = w * (thought.confidence / 100.0)
            
            vote_balance += val * signal_weight
            total_weight += signal_weight
            
            self.last_prediction[agent] = thought.signal_type

        if total_weight == 0: return None
        
        # Final Decision
        final_score = vote_balance / total_weight # -1.0 to 1.0
        
        decision = "WAIT"
        conf = 0.0
        meta = {'score': final_score, 'top_agents': []}
        
        if final_score > 0.2:
            decision = "BUY"
            conf = min(99.0, 60.0 + (final_score * 40))
        elif final_score < -0.2:
            decision = "SELL"
            conf = min(99.0, 60.0 + (abs(final_score) * 40))
            
        # Log top trusted agents
        sorted_weights = sorted(self.weights.items(), key=lambda x: x[1], reverse=True)
        meta['top_agents'] = [f"{k}:{v:.2f}" for k,v in sorted_weights[:3]]
        
        return SwarmSignal(
            source=self.name,
            signal_type=decision,
            confidence=conf,
            timestamp=time.time(),
            meta_data=meta
        )
